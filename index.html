<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AutoPrompt Standalone</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-white text-black font-sans p-4 md:p-8 max-w-xl mx-auto">
    <header class="flex items-center justify-between mb-8">
        <div class="flex items-center gap-2">
            <!-- Zap Icon -->
            <svg class="w-5 h-5 fill-black" viewBox="0 0 24 24"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg>
            <h1 class="text-lg font-bold">AutoPrompt</h1>
        </div>
        <button id="resetBtn" class="hidden text-xs font-bold text-gray-400 hover:text-black uppercase tracking-tighter">Reset</button>
    </header>

    <main class="space-y-6">
        <!-- Upload/Drop Zone -->
        <div id="dropZone" class="aspect-video rounded-xl border-2 border-dashed border-gray-100 bg-gray-50 flex flex-col items-center justify-center cursor-pointer hover:bg-gray-100 transition-colors">
            <div class="flex gap-3 mb-2">
                <svg class="w-6 h-6 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/></svg>
                <svg class="w-6 h-6 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/></svg>
            </div>
            <p class="text-xs font-bold text-gray-400 uppercase tracking-tight mb-1">Give me a file to create a video</p>
            <p class="text-[10px] font-bold text-gray-400 uppercase tracking-widest">(Or press Ctrl+V to paste)</p>
            <input type="file" id="fileInput" accept="image/*,video/*" class="hidden">
        </div>

        <!-- Preview & Result Area -->
        <div id="previewContainer" class="hidden space-y-4">
            <div class="relative aspect-video rounded-xl overflow-hidden bg-gray-100">
                <div id="mediaPreview" class="w-full h-full"></div>
                <!-- Fast Loader -->
                <div id="loader" class="hidden absolute inset-0 bg-white/40 backdrop-blur-[2px] flex items-center justify-center">
                    <div class="text-[10px] font-black tracking-[0.2em] animate-pulse">GENERATING...</div>
                </div>
            </div>
            <div id="resultCard" class="hidden p-5 bg-gray-50 rounded-xl border border-gray-100">
                <p id="promptText" class="text-sm leading-relaxed mb-4"></p>
                <button id="copyBtn" class="flex items-center gap-2 text-[10px] font-black uppercase tracking-widest text-gray-400 hover:text-black transition-colors">
                    <span>Copy</span>
                </button>
            </div>
        </div>
    </main>

    <script>
        // DOM Elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const previewContainer = document.getElementById('previewContainer');
        const mediaPreview = document.getElementById('mediaPreview');
        const loader = document.getElementById('loader');
        const resultCard = document.getElementById('resultCard');
        const promptText = document.getElementById('promptText');
        const copyBtn = document.getElementById('copyBtn');
        const resetBtn = document.getElementById('resetBtn');

        // Note: The execution environment provides the key at runtime dynamically here.
        const apiKey = ""; 

        // Exponential backoff fetch function
        async function fetchWithRetry(url, options) {
            const delays = [1000, 2000, 4000, 8000, 16000];
            for (let i = 0; i < delays.length; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) return response;
                    
                    if (i === delays.length - 1) {
                        throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
                    }
                } catch (err) {
                    if (i === delays.length - 1) throw err;
                }
                // Wait for the specified delay before retrying
                await new Promise(resolve => setTimeout(resolve, delays[i]));
            }
        }

        // --- Client-side Compression Engines to prevent Payload limit errors ---

        function compressImage(file, maxDim = 1024) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        let { width, height } = img;
                        if (width > maxDim || height > maxDim) {
                            if (width > height) {
                                height = Math.round((height * maxDim) / width);
                                width = maxDim;
                            } else {
                                width = Math.round((width * maxDim) / height);
                                height = maxDim;
                            }
                        }
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                        resolve({ base64: dataUrl.split(',')[1], mimeType: 'image/jpeg' });
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function extractVideoFrame(file, maxDim = 1024) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.setAttribute('playsinline', '');
                video.muted = true;
                const url = URL.createObjectURL(file);
                
                video.onloadeddata = () => {
                    // Seek to 1 second in, or halfway if it's a short clip
                    video.currentTime = Math.min(1, video.duration > 0 ? video.duration / 2 : 0);
                };

                video.onseeked = () => {
                    try {
                        let { videoWidth: width, videoHeight: height } = video;
                        if (width > maxDim || height > maxDim) {
                            if (width > height) {
                                height = Math.round((height * maxDim) / width);
                                width = maxDim;
                            } else {
                                width = Math.round((width * maxDim) / height);
                                height = maxDim;
                            }
                        }
                        const canvas = document.createElement('canvas');
                        canvas.width = width || 640;
                        canvas.height = height || 360;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                        URL.revokeObjectURL(url);
                        resolve({ base64: dataUrl.split(',')[1], mimeType: 'image/jpeg' });
                    } catch (e) {
                        reject(e);
                    }
                };

                video.onerror = () => {
                    URL.revokeObjectURL(url);
                    reject(new Error("Failed to load video"));
                };

                video.src = url;
                video.load();
            });
        }

        // ----------------------------------------------------------------------

        async function processFile(file) {
            dropZone.classList.add('hidden');
            previewContainer.classList.remove('hidden');
            resetBtn.classList.remove('hidden');
            
            // Show loader immediately while compressing/extracting
            loader.classList.remove('hidden');
            resultCard.classList.add('hidden');

            try {
                let base64Data, mimeType;

                if (file.type.startsWith('video/')) {
                    const previewUrl = URL.createObjectURL(file);
                    mediaPreview.innerHTML = `<video src="${previewUrl}" class="w-full h-full object-cover" autoPlay muted loop playsinline></video>`;
                    
                    // Extract a single tiny frame to send to AI
                    const frameData = await extractVideoFrame(file);
                    base64Data = frameData.base64;
                    mimeType = frameData.mimeType;
                } else if (file.type.startsWith('image/')) {
                    const previewUrl = URL.createObjectURL(file);
                    mediaPreview.innerHTML = `<img src="${previewUrl}" class="w-full h-full object-cover">`;
                    
                    // Compress image before sending
                    const compressedData = await compressImage(file);
                    base64Data = compressedData.base64;
                    mimeType = compressedData.mimeType;
                } else {
                    throw new Error("Unsupported file type");
                }

                // File is now super small and safe to send
                generatePrompt(base64Data, mimeType);
            } catch (err) {
                console.error("Compression Error:", err);
                promptText.textContent = "Error: Could not process media file format.";
                resultCard.classList.remove('hidden');
                loader.classList.add('hidden');
            }
        }

        async function generatePrompt(base64Data, mimeType) {
            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                
                const payload = {
                    contents: [{
                        role: "user",
                        parts: [
                            { text: "Act as an elite Hollywood VFX Director and AI Video Prompt Architect. Analyze the provided image/video and craft an ultra-detailed, professional video generation prompt. The prompt MUST start with exactly 'Create a cinematic video'. You must construct a dense, single-paragraph prompt that seamlessly weaves together: 1. Subject & Temporal Motion (precise physical descriptions, fluid movements over time). 2. Advanced Camera Dynamics (e.g., shot on ARRI Alexa 65, 35mm lens, dynamic tracking shot, slow-motion push-in, drone sweep). 3. Complex Lighting & Atmosphere (e.g., volumetric fog, cinematic chiaroscuro, neon practicals, golden hour rim lighting). 4. Ultimate Visual Fidelity (e.g., 8k resolution, photorealistic, shallow depth of field, Kodak 35mm film stock). Do NOT include abstract concepts, thoughts, or audio. Focus 100% on concrete, visible, cinematic elements. Output ONLY the final, continuous paragraph without any intro, outro, or bullet points." },
                            { inlineData: { mimeType: mimeType, data: base64Data } }
                        ]
                    }]
                };

                const response = await fetchWithRetry(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                promptText.textContent = text || "No prompt could be generated.";
                resultCard.classList.remove('hidden');
            } catch (err) {
                console.error('API Error:', err);
                promptText.textContent = "Error: Network issue or the file size is too large for the API payload limit. Please try again or use a smaller file.";
                resultCard.classList.remove('hidden');
            } finally {
                loader.classList.add('hidden');
            }
        }

        // Event Listeners
        dropZone.onclick = () => fileInput.click();
        fileInput.onchange = (e) => e.target.files[0] && processFile(e.target.files[0]);
        
        // This works perfectly in all environments as long as the user initiates the shortcut via keyboard
        window.onpaste = (e) => {
            const file = e.clipboardData?.items[0]?.getAsFile();
            if (file && (file.type.startsWith('image/') || file.type.startsWith('video/'))) {
                processFile(file);
            }
        };

        resetBtn.onclick = () => {
            dropZone.classList.remove('hidden');
            previewContainer.classList.add('hidden');
            resetBtn.classList.add('hidden');
            resultCard.classList.add('hidden');
            mediaPreview.innerHTML = '';
            promptText.textContent = '';
            fileInput.value = '';
        };

        copyBtn.onclick = () => {
            // Using execCommand for better iFrame compatibility
            const textArea = document.createElement("textarea");
            textArea.value = promptText.textContent;
            document.body.appendChild(textArea);
            textArea.select();
            
            try {
                document.execCommand('copy');
                const span = copyBtn.querySelector('span');
                span.textContent = 'Copied';
                setTimeout(() => span.textContent = 'Copy', 2000);
            } catch (err) {
                console.error('Copy failed', err);
            }
            
            document.body.removeChild(textArea);
        };
    </script>
</body>
</html>
